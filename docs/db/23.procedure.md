# inspig 통계 프로시저 정의서

> inspig 주간/월간 리포트용 데이터 추출 프로시저 및 스케줄러 정의

---

## 1. 개요

### 1.1 스케줄러 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                    DBMS_SCHEDULER JOB                           │
│  - JOB_INS_WEEKLY_REPORT (주간 리포트 생성)                      │
│  - 매주 월요일 03:00 실행                                        │
└─────────────────────────┬───────────────────────────────────────┘
                          │ 호출
                          ▼
┌─────────────────────────────────────────────────────────────────┐
│                SP_INS_WEEKLY_MAIN (메인 프로시저)                │
│  - TS_INS_MASTER 생성                                           │
│  - 대상 농장 목록 조회                                           │
│  - 각 서브 프로시저 순차 호출                                    │
└─────────────────────────┬───────────────────────────────────────┘
                          │ 순차 호출
        ┌─────────────────┼─────────────────┬─────────────────┐
        ▼                 ▼                 ▼                 ▼
┌────────────────┐ ┌───────────────┐ ┌───────────────┐ ┌───────────────┐
│SP_INS_MANAGE   │ │SP_INS_MODON   │ │SP_INS_GB      │ │ ... (기타)    │
│_SOW 관리대상   │ │ 모돈현황      │ │ 교배실적      │ │               │
└────────────────┘ └───────────────┘ └───────────────┘ └───────────────┘
        │                 │                 │                 │
        └─────────────────┴─────────────────┴─────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────────┐
│                    TS_INS_JOB_LOG (실행 로그)                    │
│  - 각 프로시저별 실행 시간, 상태, 오류 메시지 기록               │
│  - 대시보드에서 실시간 모니터링 가능                             │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 프로시저 목록

#### 공통 프로시저 (SP_INS_COM_)
| 프로시저명 | 설명 | 대상 테이블 |
|------------|------|-------------|
| SP_INS_COM_LOG_START | 로그 시작 | TS_INS_JOB_LOG |
| SP_INS_COM_LOG_END | 로그 종료 (성공) | TS_INS_JOB_LOG |
| SP_INS_COM_LOG_ERROR | 로그 종료 (오류) | TS_INS_JOB_LOG |
| SP_INS_COM_LOG_CLEAR | 전일 로그 삭제 | TS_INS_JOB_LOG |

#### 주간 리포트 프로시저 (SP_INS_WEEK_)
| 프로시저명 | 설명 | 대상 테이블 |
|------------|------|-------------|
| SP_INS_WEEK_MAIN | 주간 리포트 메인 | TS_INS_MASTER |
| SP_INS_WEEK_MANAGE_SOW | 관리대상 모돈 추출 | TS_INS_FARM, TS_INS_FARM_SUB |
| SP_INS_WEEK_MODON | 모돈 현황 추출 | TS_INS_FARM, TS_INS_FARM_SUB |
| SP_INS_WEEK_GB | 교배 실적 추출 | TS_INS_FARM, TS_INS_FARM_SUB |
| SP_INS_WEEK_BM | 분만 실적 추출 | TS_INS_FARM, TS_INS_FARM_SUB |
| SP_INS_WEEK_EU | 이유 실적 추출 | TS_INS_FARM, TS_INS_FARM_SUB |
| SP_INS_WEEK_SG | 임신사고 추출 | TS_INS_FARM, TS_INS_FARM_SUB |
| SP_INS_WEEK_DOPE | 도태폐사 추출 | TS_INS_FARM, TS_INS_FARM_SUB |
| SP_INS_WEEK_CH | 출하 실적 추출 | TS_INS_FARM, TS_INS_FARM_SUB |
| SP_INS_WEEK_SCHEDULE | 작업예정 추출 | TS_INS_FARM_SUB |
| SP_INS_WEEK_PSY_HEATMAP | PSY 히트맵 집계 | TS_PSY_DELAY_HEATMAP |
| SP_INS_WEEK_MGMT | 관리포인트 생성 | TS_INS_MGMT |

---

## 2. 로그 기록 유틸리티 프로시저

> **테이블 DDL**: [21.insTable.md](21.insTable.md) 섹션 4 참조 (TS_INS_JOB_LOG)

프로시저 실행 로그를 기록하는 유틸리티 프로시저입니다. 모든 데이터 추출 프로시저에서 공통으로 사용됩니다.

| 프로시저 | 용도 | 호출 시점 |
|----------|------|----------|
| SP_INS_COM_LOG_START | 로그 시작 기록 | 프로시저 시작 시 |
| SP_INS_COM_LOG_END | 성공 로그 기록 | 정상 완료 시 |
| SP_INS_COM_LOG_ERROR | 오류 로그 기록 | EXCEPTION 발생 시 |
| SP_INS_COM_LOG_CLEAR | 전일 로그 삭제 | 매일 JOB 시작 전 |

### 2.1 SP_INS_COM_LOG_START (로그 시작)

프로시저 실행 시작을 TS_INS_JOB_LOG 테이블에 기록합니다. STATUS_CD를 'RUNNING'으로 설정하고 P_LOG_SEQ를 반환합니다.

```sql
CREATE OR REPLACE PROCEDURE SP_INS_COM_LOG_START (
    P_MASTER_SEQ    IN  NUMBER,
    P_JOB_NM        IN  VARCHAR2,
    P_PROC_NM       IN  VARCHAR2,
    P_FARM_NO       IN  INTEGER DEFAULT NULL,
    P_LOG_SEQ       OUT NUMBER
) AS
BEGIN
    SELECT SEQ_TS_INS_JOB_LOG.NEXTVAL INTO P_LOG_SEQ FROM DUAL;

    INSERT INTO TS_INS_JOB_LOG (
        SEQ, MASTER_SEQ, JOB_NM, PROC_NM, FARM_NO,
        STATUS_CD, START_DT
    ) VALUES (
        P_LOG_SEQ, P_MASTER_SEQ, P_JOB_NM, P_PROC_NM, P_FARM_NO,
        'RUNNING', SYSDATE
    );

    COMMIT;
END SP_INS_COM_LOG_START;
/
```

### 2.2 SP_INS_COM_LOG_END (로그 종료 - 성공)

프로시저 정상 완료를 기록합니다. STATUS_CD를 'SUCCESS'로 변경하고, 소요시간(ELAPSED_MS)과 처리건수(PROC_CNT)를 업데이트합니다.

```sql
CREATE OR REPLACE PROCEDURE SP_INS_COM_LOG_END (
    P_LOG_SEQ       IN  NUMBER,
    P_PROC_CNT      IN  INTEGER DEFAULT 0
) AS
    V_START_DT DATE;
BEGIN
    SELECT START_DT INTO V_START_DT
    FROM TS_INS_JOB_LOG
    WHERE SEQ = P_LOG_SEQ;

    UPDATE TS_INS_JOB_LOG
    SET STATUS_CD = 'SUCCESS',
        END_DT = SYSDATE,
        ELAPSED_MS = ROUND((SYSDATE - V_START_DT) * 24 * 60 * 60 * 1000),
        PROC_CNT = P_PROC_CNT
    WHERE SEQ = P_LOG_SEQ;

    COMMIT;
END SP_INS_COM_LOG_END;
/
```

### 2.3 SP_INS_COM_LOG_ERROR (로그 종료 - 오류)

프로시저 오류 발생을 기록합니다. STATUS_CD를 'ERROR'로 변경하고, 오류코드(ERROR_CD)와 오류메시지(ERROR_MSG)를 저장합니다.

```sql
CREATE OR REPLACE PROCEDURE SP_INS_COM_LOG_ERROR (
    P_LOG_SEQ       IN  NUMBER,
    P_ERROR_CD      IN  VARCHAR2,
    P_ERROR_MSG     IN  VARCHAR2
) AS
    V_START_DT DATE;
BEGIN
    SELECT START_DT INTO V_START_DT
    FROM TS_INS_JOB_LOG
    WHERE SEQ = P_LOG_SEQ;

    UPDATE TS_INS_JOB_LOG
    SET STATUS_CD = 'ERROR',
        END_DT = SYSDATE,
        ELAPSED_MS = ROUND((SYSDATE - V_START_DT) * 24 * 60 * 60 * 1000),
        ERROR_CD = P_ERROR_CD,
        ERROR_MSG = SUBSTR(P_ERROR_MSG, 1, 4000)
    WHERE SEQ = P_LOG_SEQ;

    COMMIT;
END SP_INS_COM_LOG_ERROR;
/
```

### 2.4 SP_INS_COM_LOG_CLEAR (전일 로그 삭제)

JOB 실행 전 전일 로그를 삭제하여 당일 로그만 유지합니다. SP_INS_WEEK_MAIN 프로시저 시작 시 자동 호출됩니다.

> **참고**: 장기 보관이 필요한 경우 별도 히스토리 테이블로 이관 후 삭제 권장

```sql
CREATE OR REPLACE PROCEDURE SP_INS_COM_LOG_CLEAR AS
    V_DEL_CNT INTEGER;
BEGIN
    -- 전일 이전 로그 삭제
    DELETE FROM TS_INS_JOB_LOG
    WHERE START_DT < TRUNC(SYSDATE);

    V_DEL_CNT := SQL%ROWCOUNT;
    COMMIT;

    -- 삭제 건수 로깅 (선택적)
    IF V_DEL_CNT > 0 THEN
        DBMS_OUTPUT.PUT_LINE('TS_INS_JOB_LOG 삭제: ' || V_DEL_CNT || '건');
    END IF;
END SP_INS_COM_LOG_CLEAR;
/
```

---

## 3. 관리대상 모돈 추출 프로시저 (SP_INS_WEEK_MANAGE_SOW)

농장별 관리대상 모돈(미교배, 분만지연, 이유지연 등)을 추출하여 TS_INS_FARM, TS_INS_FARM_SUB 테이블에 저장합니다.

### 3.1 개요

| 항목 | 내용 |
|------|------|
| **용도** | 주간 리포트 - 관리대상 모돈 섹션 데이터 생성 |
| **입력** | MASTER_SEQ, FARM_NO, 기간(DT_FROM~DT_TO) |
| **출력** | TS_INS_FARM (요약), TS_INS_FARM_SUB (GUBUN='ALERT') |
| **호출** | SP_INS_WEEK_MAIN에서 농장별 순차 호출 |

#### 추출 대상
| 유형 | 설명 | 기준 |
|------|------|------|
| 미교배 후보돈 | 초교배일 경과 후보돈 | (오늘-출생일) > 초교배일(140007) |
| 이유후 미교배 | 이유 후 재귀일 경과 모돈 | (오늘-이유일) > 평균재귀일(140008) |
| 사고후 미교배 | 사고 후 미교배 모돈 | 사고 후 교배 미등록 |
| 분만지연 | 교배 후 임신기간 경과 모돈 | (오늘-교배일) > 임신기간(140002) |
| 이유지연 | 분만 후 이유기간 경과 모돈 | (오늘-분만일) > 이유기간(140003) |

#### 기간별 구분
- `~3`: 경과일 0~3일
- `4~7`: 경과일 4~7일
- `8~14`: 경과일 8~14일
- `14~`: 경과일 14일 이상

### 3.2 프로시저 정의

```sql
CREATE OR REPLACE PROCEDURE SP_INS_WEEK_MANAGE_SOW (
    P_MASTER_SEQ    IN  NUMBER,
    P_JOB_NM        IN  VARCHAR2,
    P_FARM_NO       IN  INTEGER,
    P_DT_FROM       IN  DATE,
    P_DT_TO         IN  DATE
) AS
    V_LOG_SEQ       NUMBER;
    V_PROC_CNT      INTEGER := 0;
    V_TODAY         DATE;

    -- 농장 설정값
    V_FIRST_MATING_AGE  NUMBER;  -- 140007: 초교배일
    V_AVG_RETURN_DAY    NUMBER;  -- 140008: 평균재귀일
    V_PREG_PERIOD       NUMBER;  -- 140002: 임신기간
    V_WEAN_PERIOD       NUMBER;  -- 140003: 이유기간

    -- 관리대상 집계 변수
    TYPE T_MANAGE_REC IS RECORD (
        PERIOD      VARCHAR2(10),
        HUBO        INTEGER,
        EU_MI       INTEGER,
        SG_MI       INTEGER,
        BM_DELAY    INTEGER,
        EU_DELAY    INTEGER
    );
    TYPE T_MANAGE_TAB IS TABLE OF T_MANAGE_REC INDEX BY PLS_INTEGER;
    V_MANAGE_DATA   T_MANAGE_TAB;

    -- 합계 변수
    V_TOTAL_HUBO    INTEGER := 0;
    V_TOTAL_EU_MI   INTEGER := 0;
    V_TOTAL_SG_MI   INTEGER := 0;
    V_TOTAL_BM_DELAY INTEGER := 0;
    V_TOTAL_EU_DELAY INTEGER := 0;

BEGIN
    -- 로그 시작
    SP_INS_COM_LOG_START(P_MASTER_SEQ, P_JOB_NM, 'SP_INS_WEEK_MANAGE_SOW', P_FARM_NO, V_LOG_SEQ);

    -- 기준일 설정
    V_TODAY := TRUNC(SF_GET_LOCALE_VW_DATE_2022(NULL, SYSDATE));

    -- 농장 설정값 조회
    BEGIN
        SELECT MAX(CASE WHEN CODE = '140007' THEN TO_NUMBER(CVALUE) END),
               MAX(CASE WHEN CODE = '140008' THEN TO_NUMBER(CVALUE) END),
               MAX(CASE WHEN CODE = '140002' THEN TO_NUMBER(CVALUE) END),
               MAX(CASE WHEN CODE = '140003' THEN TO_NUMBER(CVALUE) END)
        INTO V_FIRST_MATING_AGE, V_AVG_RETURN_DAY, V_PREG_PERIOD, V_WEAN_PERIOD
        FROM TC_FARM_CONFIG
        WHERE FARM_NO = P_FARM_NO
        AND CODE IN ('140007', '140008', '140002', '140003');
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

    -- 기본값 설정
    V_FIRST_MATING_AGE := NVL(V_FIRST_MATING_AGE, 240);
    V_AVG_RETURN_DAY := NVL(V_AVG_RETURN_DAY, 7);
    V_PREG_PERIOD := NVL(V_PREG_PERIOD, 115);
    V_WEAN_PERIOD := NVL(V_WEAN_PERIOD, 21);

    -- 기간별 초기화
    FOR i IN 1..4 LOOP
        V_MANAGE_DATA(i).HUBO := 0;
        V_MANAGE_DATA(i).EU_MI := 0;
        V_MANAGE_DATA(i).SG_MI := 0;
        V_MANAGE_DATA(i).BM_DELAY := 0;
        V_MANAGE_DATA(i).EU_DELAY := 0;
        CASE i
            WHEN 1 THEN V_MANAGE_DATA(i).PERIOD := '~3';
            WHEN 2 THEN V_MANAGE_DATA(i).PERIOD := '4~7';
            WHEN 3 THEN V_MANAGE_DATA(i).PERIOD := '8~14';
            WHEN 4 THEN V_MANAGE_DATA(i).PERIOD := '14~';
        END CASE;
    END LOOP;

    -- ================================================
    -- 1. 미교배 후보돈 (NOT_GY_HUBO)
    -- ================================================
    FOR rec IN (
        SELECT CASE
                   WHEN (V_TODAY - MD.BIRTH_DT) - V_FIRST_MATING_AGE <= 3 THEN 1
                   WHEN (V_TODAY - MD.BIRTH_DT) - V_FIRST_MATING_AGE <= 7 THEN 2
                   WHEN (V_TODAY - MD.BIRTH_DT) - V_FIRST_MATING_AGE <= 14 THEN 3
                   ELSE 4
               END AS PERIOD_IDX,
               COUNT(*) AS CNT
        FROM TB_MODON MD
        LEFT OUTER JOIN TB_MODON_WK WK
            ON WK.FARM_NO = P_FARM_NO
            AND WK.FARM_NO = MD.FARM_NO
            AND WK.PIG_NO = MD.PIG_NO
            AND WK.USE_YN = 'Y'
        WHERE MD.FARM_NO = P_FARM_NO
            AND WK.FARM_NO IS NULL
            AND MD.IN_DT < V_TODAY + 1
            AND MD.OUT_DT = TO_DATE('9999-12-31', 'YYYY-MM-DD')
            AND MD.STATUS_CD = '010001'
            AND (V_TODAY - MD.BIRTH_DT) - V_FIRST_MATING_AGE >= 0
            AND MD.USE_YN = 'Y'
        GROUP BY CASE
                     WHEN (V_TODAY - MD.BIRTH_DT) - V_FIRST_MATING_AGE <= 3 THEN 1
                     WHEN (V_TODAY - MD.BIRTH_DT) - V_FIRST_MATING_AGE <= 7 THEN 2
                     WHEN (V_TODAY - MD.BIRTH_DT) - V_FIRST_MATING_AGE <= 14 THEN 3
                     ELSE 4
                 END
    ) LOOP
        V_MANAGE_DATA(rec.PERIOD_IDX).HUBO := rec.CNT;
        V_TOTAL_HUBO := V_TOTAL_HUBO + rec.CNT;
    END LOOP;

    -- ================================================
    -- 2. 이유후 미교배돈 (NOT_GY_EU)
    -- ================================================
    FOR rec IN (
        SELECT PERIOD_IDX, SUM(CNT) AS CNT
        FROM (
            -- 작업 정보에서 추출
            SELECT CASE
                       WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_AVG_RETURN_DAY + 1 <= 3 THEN 1
                       WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_AVG_RETURN_DAY + 1 <= 7 THEN 2
                       WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_AVG_RETURN_DAY + 1 <= 14 THEN 3
                       ELSE 4
                   END AS PERIOD_IDX,
                   COUNT(*) AS CNT
            FROM VM_LAST_MODON_SEQ_WK WK
            INNER JOIN TB_MODON MD
                ON MD.FARM_NO = P_FARM_NO
                AND MD.FARM_NO = WK.FARM_NO
                AND MD.PIG_NO = WK.PIG_NO
                AND MD.OUT_DT = TO_DATE('9999-12-31', 'YYYY-MM-DD')
                AND MD.USE_YN = 'Y'
            WHERE WK.FARM_NO = P_FARM_NO
                AND WK.WK_GUBUN = 'E'
                AND WK.DAERI_YN = 'N'
                AND (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) + 1 >= V_AVG_RETURN_DAY
            GROUP BY CASE
                         WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_AVG_RETURN_DAY + 1 <= 3 THEN 1
                         WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_AVG_RETURN_DAY + 1 <= 7 THEN 2
                         WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_AVG_RETURN_DAY + 1 <= 14 THEN 3
                         ELSE 4
                     END

            UNION ALL

            -- 작업정보 없는 전입된 이유모돈
            SELECT CASE
                       WHEN (V_TODAY - MD.LAST_WK_DT) - V_AVG_RETURN_DAY <= 3 THEN 1
                       WHEN (V_TODAY - MD.LAST_WK_DT) - V_AVG_RETURN_DAY <= 7 THEN 2
                       WHEN (V_TODAY - MD.LAST_WK_DT) - V_AVG_RETURN_DAY <= 14 THEN 3
                       ELSE 4
                   END AS PERIOD_IDX,
                   COUNT(*) AS CNT
            FROM TB_MODON MD
            LEFT OUTER JOIN TB_MODON_WK WK
                ON WK.FARM_NO = P_FARM_NO
                AND WK.FARM_NO = MD.FARM_NO
                AND WK.PIG_NO = MD.PIG_NO
                AND WK.USE_YN = 'Y'
            WHERE MD.FARM_NO = P_FARM_NO
                AND WK.FARM_NO IS NULL
                AND MD.IN_DT < V_TODAY + 1
                AND (V_TODAY - MD.LAST_WK_DT) - V_AVG_RETURN_DAY >= 0
                AND MD.STATUS_CD = '010005'
                AND MD.OUT_DT = TO_DATE('9999-12-31', 'YYYY-MM-DD')
                AND MD.USE_YN = 'Y'
            GROUP BY CASE
                         WHEN (V_TODAY - MD.LAST_WK_DT) - V_AVG_RETURN_DAY <= 3 THEN 1
                         WHEN (V_TODAY - MD.LAST_WK_DT) - V_AVG_RETURN_DAY <= 7 THEN 2
                         WHEN (V_TODAY - MD.LAST_WK_DT) - V_AVG_RETURN_DAY <= 14 THEN 3
                         ELSE 4
                     END
        )
        GROUP BY PERIOD_IDX
    ) LOOP
        V_MANAGE_DATA(rec.PERIOD_IDX).EU_MI := rec.CNT;
        V_TOTAL_EU_MI := V_TOTAL_EU_MI + rec.CNT;
    END LOOP;

    -- ================================================
    -- 3. 사고후 미교배돈 (NOT_GY_SG)
    -- ================================================
    FOR rec IN (
        SELECT PERIOD_IDX, SUM(CNT) AS CNT
        FROM (
            -- 작업 정보에서 추출
            SELECT CASE
                       WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) <= 3 THEN 1
                       WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) <= 7 THEN 2
                       WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) <= 14 THEN 3
                       ELSE 4
                   END AS PERIOD_IDX,
                   COUNT(*) AS CNT
            FROM VM_LAST_MODON_SEQ_WK WK
            INNER JOIN TB_MODON MD
                ON MD.FARM_NO = P_FARM_NO
                AND MD.FARM_NO = WK.FARM_NO
                AND MD.PIG_NO = WK.PIG_NO
                AND MD.OUT_DT = TO_DATE('9999-12-31', 'YYYY-MM-DD')
                AND MD.USE_YN = 'Y'
            WHERE WK.FARM_NO = P_FARM_NO
                AND WK.WK_GUBUN = 'F'
                AND (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) >= 0
            GROUP BY CASE
                         WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) <= 3 THEN 1
                         WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) <= 7 THEN 2
                         WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) <= 14 THEN 3
                         ELSE 4
                     END

            UNION ALL

            -- 작업정보 없는 전입된 사고돈
            SELECT CASE
                       WHEN (V_TODAY - MD.LAST_WK_DT) <= 3 THEN 1
                       WHEN (V_TODAY - MD.LAST_WK_DT) <= 7 THEN 2
                       WHEN (V_TODAY - MD.LAST_WK_DT) <= 14 THEN 3
                       ELSE 4
                   END AS PERIOD_IDX,
                   COUNT(*) AS CNT
            FROM TB_MODON MD
            LEFT OUTER JOIN TB_MODON_WK WK
                ON WK.FARM_NO = P_FARM_NO
                AND WK.FARM_NO = MD.FARM_NO
                AND WK.PIG_NO = MD.PIG_NO
                AND WK.USE_YN = 'Y'
            WHERE MD.FARM_NO = P_FARM_NO
                AND WK.FARM_NO IS NULL
                AND MD.IN_DT < V_TODAY + 1
                AND MD.OUT_DT = TO_DATE('9999-12-31', 'YYYY-MM-DD')
                AND (V_TODAY - MD.LAST_WK_DT) >= 0
                AND MD.STATUS_CD IN ('010006', '010007')
                AND MD.USE_YN = 'Y'
            GROUP BY CASE
                         WHEN (V_TODAY - MD.LAST_WK_DT) <= 3 THEN 1
                         WHEN (V_TODAY - MD.LAST_WK_DT) <= 7 THEN 2
                         WHEN (V_TODAY - MD.LAST_WK_DT) <= 14 THEN 3
                         ELSE 4
                     END
        )
        GROUP BY PERIOD_IDX
    ) LOOP
        V_MANAGE_DATA(rec.PERIOD_IDX).SG_MI := rec.CNT;
        V_TOTAL_SG_MI := V_TOTAL_SG_MI + rec.CNT;
    END LOOP;

    -- ================================================
    -- 4. 교배후 미분만돈 (NOT_BM_GY)
    -- ================================================
    FOR rec IN (
        SELECT CASE
                   WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_PREG_PERIOD <= 3 THEN 1
                   WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_PREG_PERIOD <= 7 THEN 2
                   WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_PREG_PERIOD <= 14 THEN 3
                   ELSE 4
               END AS PERIOD_IDX,
               COUNT(*) AS CNT
        FROM VM_LAST_MODON_SEQ_WK WK
        INNER JOIN TB_MODON MD
            ON MD.FARM_NO = P_FARM_NO
            AND MD.FARM_NO = WK.FARM_NO
            AND MD.PIG_NO = WK.PIG_NO
            AND MD.OUT_DT = TO_DATE('9999-12-31', 'YYYY-MM-DD')
            AND MD.USE_YN = 'Y'
        WHERE WK.FARM_NO = P_FARM_NO
            AND WK.WK_GUBUN = 'G'
            AND (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_PREG_PERIOD >= 0
        GROUP BY CASE
                     WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_PREG_PERIOD <= 3 THEN 1
                     WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_PREG_PERIOD <= 7 THEN 2
                     WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_PREG_PERIOD <= 14 THEN 3
                     ELSE 4
                 END
    ) LOOP
        V_MANAGE_DATA(rec.PERIOD_IDX).BM_DELAY := rec.CNT;
        V_TOTAL_BM_DELAY := V_TOTAL_BM_DELAY + rec.CNT;
    END LOOP;

    -- ================================================
    -- 5. 분만후 미이유돈 (NOT_EU_BM)
    -- ================================================
    FOR rec IN (
        SELECT CASE
                   WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_WEAN_PERIOD <= 3 THEN 1
                   WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_WEAN_PERIOD <= 7 THEN 2
                   WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_WEAN_PERIOD <= 14 THEN 3
                   ELSE 4
               END AS PERIOD_IDX,
               COUNT(*) AS CNT
        FROM VM_LAST_MODON_SEQ_WK WK
        INNER JOIN TB_MODON MD
            ON MD.FARM_NO = P_FARM_NO
            AND MD.FARM_NO = WK.FARM_NO
            AND MD.PIG_NO = WK.PIG_NO
            AND MD.OUT_DT = TO_DATE('9999-12-31', 'YYYY-MM-DD')
            AND MD.USE_YN = 'Y'
        WHERE WK.FARM_NO = P_FARM_NO
            AND WK.WK_GUBUN = 'B'
            AND (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_WEAN_PERIOD >= 0
        GROUP BY CASE
                     WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_WEAN_PERIOD <= 3 THEN 1
                     WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_WEAN_PERIOD <= 7 THEN 2
                     WHEN (V_TODAY - TO_DATE(WK.WK_DT, 'YYYY-MM-DD')) - V_WEAN_PERIOD <= 14 THEN 3
                     ELSE 4
                 END
    ) LOOP
        V_MANAGE_DATA(rec.PERIOD_IDX).EU_DELAY := rec.CNT;
        V_TOTAL_EU_DELAY := V_TOTAL_EU_DELAY + rec.CNT;
    END LOOP;

    -- ================================================
    -- TS_INS_FARM 업데이트 (요약 데이터)
    -- ================================================
    UPDATE TS_INS_FARM
    SET ALERT_TOTAL = V_TOTAL_HUBO + V_TOTAL_EU_MI + V_TOTAL_SG_MI + V_TOTAL_BM_DELAY + V_TOTAL_EU_DELAY,
        ALERT_EU_MI = V_TOTAL_EU_MI,
        ALERT_SG_MI = V_TOTAL_SG_MI,
        ALERT_BM_DELAY = V_TOTAL_BM_DELAY,
        ALERT_EU_DELAY = V_TOTAL_EU_DELAY
    WHERE MASTER_SEQ = P_MASTER_SEQ
    AND FARM_NO = P_FARM_NO;

    -- ================================================
    -- TS_INS_FARM_SUB INSERT (상세 데이터)
    -- ================================================
    -- 기존 데이터 삭제
    DELETE FROM TS_INS_FARM_SUB
    WHERE MASTER_SEQ = P_MASTER_SEQ
    AND FARM_NO = P_FARM_NO
    AND GUBUN = 'ALERT';

    -- 기간별 데이터 INSERT
    FOR i IN 1..4 LOOP
        INSERT INTO TS_INS_FARM_SUB (
            MASTER_SEQ, FARM_NO, GUBUN, SORT_NO,
            CODE_1, CNT_1, CNT_2, CNT_3, CNT_4, CNT_5
        ) VALUES (
            P_MASTER_SEQ, P_FARM_NO, 'ALERT', i,
            V_MANAGE_DATA(i).PERIOD,
            V_MANAGE_DATA(i).HUBO,
            V_MANAGE_DATA(i).EU_MI,
            V_MANAGE_DATA(i).SG_MI,
            V_MANAGE_DATA(i).BM_DELAY,
            V_MANAGE_DATA(i).EU_DELAY
        );
        V_PROC_CNT := V_PROC_CNT + 1;
    END LOOP;

    COMMIT;

    -- 로그 종료 (성공)
    SP_INS_COM_LOG_END(V_LOG_SEQ, V_PROC_CNT);

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        SP_INS_COM_LOG_ERROR(V_LOG_SEQ, SQLCODE, SQLERRM);
        RAISE;
END SP_INS_WEEK_MANAGE_SOW;
/
```

---

## 4. 메인 프로시저 (SP_INS_WEEK_MAIN)

주간 리포트 생성의 진입점이 되는 메인 프로시저입니다. DBMS_SCHEDULER JOB에서 호출됩니다.

### 4.1 개요

| 항목 | 내용 |
|------|------|
| **용도** | 주간 리포트 생성 전체 프로세스 관리 |
| **입력** | DAY_GB (WEEK/MON/QT), BASE_DT (기준일) |
| **출력** | TS_INS_MASTER, TS_INS_FARM 등 전체 테이블 |
| **호출** | JOB_INS_WEEKLY_REPORT (매주 월요일 03:00) |

#### 실행 순서
```
0. TA_SYS_CONFIG.INS_SCHEDULE_YN 체크 → 'Y'가 아니면 즉시 종료
1. SP_INS_COM_LOG_CLEAR    → 전일 로그 삭제
2. TS_INS_MASTER 생성       → 마스터 레코드 INSERT
3. TS_INS_FARM 초기화       → 대상 농장별 레코드 생성
4. 농장별 프로시저 호출:
   - SP_INS_WEEK_MANAGE_SOW → 관리대상 모돈
   - SP_INS_WEEK_MODON      → 모돈 현황 (예정)
   - SP_INS_WEEK_GB         → 교배 실적 (예정)
   - SP_INS_WEEK_BM         → 분만 실적 (예정)
   - SP_INS_WEEK_EU         → 이유 실적 (예정)
   - SP_INS_WEEK_SG         → 임신사고 (예정)
   - SP_INS_WEEK_DOPE       → 도태폐사 (예정)
   - SP_INS_WEEK_CH         → 출하 실적 (예정)
   - SP_INS_WEEK_SCHEDULE   → 작업예정 (예정)
5. SP_INS_WEEK_PSY_HEATMAP → PSY 히트맵 집계
6. SP_INS_WEEK_MGMT        → 관리포인트 생성
7. TS_INS_MASTER 상태 업데이트 → COMPLETE/ERROR
```

### 4.2 프로시저 정의

```sql
CREATE OR REPLACE PROCEDURE SP_INS_WEEK_MAIN (
    P_DAY_GB        IN  VARCHAR2 DEFAULT 'WEEK',    -- WEEK, MON, QT
    P_BASE_DT       IN  DATE DEFAULT NULL           -- 기준일 (NULL=오늘)
) AS
    V_JOB_NM        VARCHAR2(50) := 'JOB_INS_WEEKLY_REPORT';
    V_LOG_SEQ       NUMBER;
    V_MASTER_SEQ    NUMBER;
    V_BASE_DT       DATE;
    V_DT_FROM       DATE;
    V_DT_TO         DATE;
    V_YEAR          NUMBER(4);
    V_WEEK_NO       NUMBER(2);
    V_TARGET_CNT    INTEGER := 0;
    V_COMPLETE_CNT  INTEGER := 0;
    V_ERROR_CNT     INTEGER := 0;
    V_SCHEDULE_YN   VARCHAR2(1);

BEGIN
    -- ================================================
    -- 0. 스케줄 실행 여부 체크 (TA_SYS_CONFIG)
    -- ================================================
    SELECT NVL(INS_SCHEDULE_YN, 'N') INTO V_SCHEDULE_YN
    FROM TA_SYS_CONFIG
    WHERE ROWNUM = 1;

    IF V_SCHEDULE_YN != 'Y' THEN
        DBMS_OUTPUT.PUT_LINE('INS_SCHEDULE_YN = N : 스케줄 실행 중단');
        RETURN;
    END IF;

    -- ================================================
    -- 1. 전일 로그 삭제 (당일 로그만 유지)
    -- ================================================
    SP_INS_COM_LOG_CLEAR;

    -- 기준일 설정
    V_BASE_DT := NVL(P_BASE_DT, TRUNC(SYSDATE));

    -- 주차 계산 (ISO Week)
    V_YEAR := TO_NUMBER(TO_CHAR(V_BASE_DT, 'IYYY'));
    V_WEEK_NO := TO_NUMBER(TO_CHAR(V_BASE_DT, 'IW'));

    -- 기간 계산 (지난주)
    V_DT_TO := TRUNC(V_BASE_DT, 'IW') - 1;  -- 지난주 일요일
    V_DT_FROM := V_DT_TO - 6;                -- 지난주 월요일

    -- ================================================
    -- 1. TS_INS_MASTER 생성
    -- ================================================
    SELECT SEQ_TS_INS_MASTER.NEXTVAL INTO V_MASTER_SEQ FROM DUAL;

    INSERT INTO TS_INS_MASTER (
        SEQ, DAY_GB, INS_DT, REPORT_YEAR, REPORT_WEEK_NO,
        DT_FROM, DT_TO, STATUS_CD, START_DT
    ) VALUES (
        V_MASTER_SEQ, P_DAY_GB, TO_CHAR(V_BASE_DT, 'YYYYMMDD'),
        V_YEAR, V_WEEK_NO, V_DT_FROM, V_DT_TO, 'RUNNING', SYSDATE
    );
    COMMIT;

    -- 메인 로그 시작
    SP_INS_COM_LOG_START(V_MASTER_SEQ, V_JOB_NM, 'SP_INS_WEEK_MAIN', NULL, V_LOG_SEQ);

    -- ================================================
    -- 2. 대상 농장 조회 및 TS_INS_FARM 초기 생성
    -- ================================================
    FOR farm_rec IN (
        SELECT DISTINCT F.FARM_NO, F.FARM_NM, F.OWNER_NM, F.SIGUNGU_CD
        FROM TM_FARM F
        WHERE F.USE_YN = 'Y'
        AND F.SERVICE_STATUS = 'ACTIVE'
        ORDER BY F.FARM_NO
    ) LOOP
        V_TARGET_CNT := V_TARGET_CNT + 1;

        -- TS_INS_FARM 초기 레코드 생성
        INSERT INTO TS_INS_FARM (
            MASTER_SEQ, FARM_NO, REPORT_YEAR, REPORT_WEEK_NO,
            DT_FROM, DT_TO, FARM_NM, OWNER_NM, SIGUNGU_CD, STATUS_CD
        ) VALUES (
            V_MASTER_SEQ, farm_rec.FARM_NO, V_YEAR, V_WEEK_NO,
            V_DT_FROM, V_DT_TO, farm_rec.FARM_NM, farm_rec.OWNER_NM,
            farm_rec.SIGUNGU_CD, 'READY'
        );
    END LOOP;
    COMMIT;

    -- MASTER 대상 농장수 업데이트
    UPDATE TS_INS_MASTER
    SET TARGET_CNT = V_TARGET_CNT
    WHERE SEQ = V_MASTER_SEQ;
    COMMIT;

    -- ================================================
    -- 3. 농장별 데이터 추출
    -- ================================================
    FOR farm_rec IN (
        SELECT FARM_NO FROM TS_INS_FARM
        WHERE MASTER_SEQ = V_MASTER_SEQ
        ORDER BY FARM_NO
    ) LOOP
        BEGIN
            -- 농장 상태 업데이트 (RUNNING)
            UPDATE TS_INS_FARM
            SET STATUS_CD = 'RUNNING'
            WHERE MASTER_SEQ = V_MASTER_SEQ AND FARM_NO = farm_rec.FARM_NO;
            COMMIT;

            -- ================================================
            -- 각 프로시저 호출
            -- ================================================

            -- 관리대상 모돈
            SP_INS_WEEK_MANAGE_SOW(V_MASTER_SEQ, V_JOB_NM, farm_rec.FARM_NO, V_DT_FROM, V_DT_TO);

            -- TODO: 추가 프로시저 호출
            -- SP_INS_MODON(V_MASTER_SEQ, V_JOB_NM, farm_rec.FARM_NO, V_DT_FROM, V_DT_TO);
            -- SP_INS_GB(V_MASTER_SEQ, V_JOB_NM, farm_rec.FARM_NO, V_DT_FROM, V_DT_TO);
            -- SP_INS_BM(V_MASTER_SEQ, V_JOB_NM, farm_rec.FARM_NO, V_DT_FROM, V_DT_TO);
            -- SP_INS_EU(V_MASTER_SEQ, V_JOB_NM, farm_rec.FARM_NO, V_DT_FROM, V_DT_TO);
            -- SP_INS_SG(V_MASTER_SEQ, V_JOB_NM, farm_rec.FARM_NO, V_DT_FROM, V_DT_TO);
            -- SP_INS_DOPE(V_MASTER_SEQ, V_JOB_NM, farm_rec.FARM_NO, V_DT_FROM, V_DT_TO);
            -- SP_INS_CH(V_MASTER_SEQ, V_JOB_NM, farm_rec.FARM_NO, V_DT_FROM, V_DT_TO);
            -- SP_INS_SCHEDULE(V_MASTER_SEQ, V_JOB_NM, farm_rec.FARM_NO, V_DT_FROM, V_DT_TO);

            -- 농장 상태 업데이트 (COMPLETE)
            UPDATE TS_INS_FARM
            SET STATUS_CD = 'COMPLETE'
            WHERE MASTER_SEQ = V_MASTER_SEQ AND FARM_NO = farm_rec.FARM_NO;
            COMMIT;

            V_COMPLETE_CNT := V_COMPLETE_CNT + 1;

        EXCEPTION
            WHEN OTHERS THEN
                -- 농장 상태 업데이트 (ERROR)
                UPDATE TS_INS_FARM
                SET STATUS_CD = 'ERROR',
                    ERROR_MSG = SUBSTR(SQLERRM, 1, 4000)
                WHERE MASTER_SEQ = V_MASTER_SEQ AND FARM_NO = farm_rec.FARM_NO;
                COMMIT;

                V_ERROR_CNT := V_ERROR_CNT + 1;
        END;
    END LOOP;

    -- ================================================
    -- 4. PSY 히트맵 집계 (전체 농장 대상)
    -- ================================================
    -- SP_INS_PSY_HEATMAP(V_MASTER_SEQ, V_JOB_NM);

    -- ================================================
    -- 5. 관리포인트 생성
    -- ================================================
    -- SP_INS_MGMT(V_MASTER_SEQ, V_JOB_NM);

    -- ================================================
    -- 6. MASTER 상태 업데이트
    -- ================================================
    UPDATE TS_INS_MASTER
    SET STATUS_CD = CASE WHEN V_ERROR_CNT > 0 THEN 'ERROR' ELSE 'COMPLETE' END,
        COMPLETE_CNT = V_COMPLETE_CNT,
        ERROR_CNT = V_ERROR_CNT,
        END_DT = SYSDATE,
        ELAPSED_SEC = ROUND((SYSDATE - START_DT) * 24 * 60 * 60)
    WHERE SEQ = V_MASTER_SEQ;
    COMMIT;

    -- 메인 로그 종료
    SP_INS_COM_LOG_END(V_LOG_SEQ, V_TARGET_CNT);

EXCEPTION
    WHEN OTHERS THEN
        -- MASTER 상태 업데이트 (ERROR)
        UPDATE TS_INS_MASTER
        SET STATUS_CD = 'ERROR',
            END_DT = SYSDATE,
            ELAPSED_SEC = ROUND((SYSDATE - START_DT) * 24 * 60 * 60)
        WHERE SEQ = V_MASTER_SEQ;
        COMMIT;

        SP_INS_COM_LOG_ERROR(V_LOG_SEQ, SQLCODE, SQLERRM);
        RAISE;
END SP_INS_WEEK_MAIN;
/
```

---

## 5. 스케줄러 JOB 생성

Oracle DBMS_SCHEDULER를 이용한 자동 실행 JOB 설정입니다.

### 5.1 개요

| JOB 이름 | 프로시저 | 실행 주기 | 설명 |
|----------|----------|----------|------|
| JOB_INS_WEEKLY_REPORT | SP_INS_WEEK_MAIN | 매주 월요일 03:00 | 주간 리포트 생성 |
| JOB_INS_MONTHLY_REPORT | SP_INS_MON_MAIN | 매월 1일 04:00 | 월간 리포트 생성 (예정) |
| JOB_INS_QUARTERLY_REPORT | SP_INS_QT_MAIN | 분기 첫날 05:00 | 분기 리포트 생성 (예정) |

### 5.2 주간 리포트 JOB

```sql
-- 기존 JOB 삭제 (있는 경우)
BEGIN
    DBMS_SCHEDULER.DROP_JOB(job_name => 'JOB_INS_WEEKLY_REPORT', force => TRUE);
EXCEPTION
    WHEN OTHERS THEN NULL;
END;
/

-- JOB 생성
BEGIN
    DBMS_SCHEDULER.CREATE_JOB (
        job_name        => 'JOB_INS_WEEKLY_REPORT',
        job_type        => 'STORED_PROCEDURE',
        job_action      => 'SP_INS_WEEK_MAIN',
        number_of_arguments => 2,
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=WEEKLY; BYDAY=MON; BYHOUR=3; BYMINUTE=0; BYSECOND=0',
        enabled         => FALSE,
        comments        => '주간 리포트 생성 (매주 월요일 03:00)'
    );

    -- 파라미터 설정
    DBMS_SCHEDULER.SET_JOB_ARGUMENT_VALUE(
        job_name          => 'JOB_INS_WEEKLY_REPORT',
        argument_position => 1,
        argument_value    => 'WEEK'
    );
    DBMS_SCHEDULER.SET_JOB_ARGUMENT_VALUE(
        job_name          => 'JOB_INS_WEEKLY_REPORT',
        argument_position => 2,
        argument_value    => NULL
    );

    -- JOB 활성화
    DBMS_SCHEDULER.ENABLE('JOB_INS_WEEKLY_REPORT');
END;
/
```

### 5.3 JOB 관리 명령어

```sql
-- JOB 목록 조회
SELECT JOB_NAME, JOB_TYPE, STATE, ENABLED, NEXT_RUN_DATE, LAST_START_DATE, LAST_RUN_DURATION
FROM USER_SCHEDULER_JOBS
WHERE JOB_NAME LIKE 'JOB_INS%';

-- JOB 즉시 실행 (테스트용)
BEGIN
    DBMS_SCHEDULER.RUN_JOB('JOB_INS_WEEKLY_REPORT');
END;
/

-- JOB 비활성화
BEGIN
    DBMS_SCHEDULER.DISABLE('JOB_INS_WEEKLY_REPORT');
END;
/

-- JOB 활성화
BEGIN
    DBMS_SCHEDULER.ENABLE('JOB_INS_WEEKLY_REPORT');
END;
/

-- JOB 실행 이력 조회
SELECT JOB_NAME, STATUS, ACTUAL_START_DATE, RUN_DURATION, ERROR#, ADDITIONAL_INFO
FROM USER_SCHEDULER_JOB_RUN_DETAILS
WHERE JOB_NAME = 'JOB_INS_WEEKLY_REPORT'
ORDER BY ACTUAL_START_DATE DESC
FETCH FIRST 10 ROWS ONLY;
```

---

## 6. 수동 실행 방법

### 6.1 전체 주간 리포트 생성

```sql
-- 오늘 기준으로 지난주 리포트 생성
BEGIN
    SP_INS_WEEK_MAIN('WEEK', SYSDATE);
END;
/

-- 특정 날짜 기준으로 리포트 생성
BEGIN
    SP_INS_WEEK_MAIN('WEEK', TO_DATE('2024-11-25', 'YYYY-MM-DD'));
END;
/
```

### 6.2 특정 농장만 관리대상 모돈 추출

```sql
-- 농장번호 105의 관리대상 모돈 추출
BEGIN
    SP_INS_WEEK_MANAGE_SOW(
        P_MASTER_SEQ => 1,  -- 기존 MASTER_SEQ
        P_JOB_NM     => 'MANUAL',
        P_FARM_NO    => 105,
        P_DT_FROM    => TO_DATE('2024-11-18', 'YYYY-MM-DD'),
        P_DT_TO      => TO_DATE('2024-11-24', 'YYYY-MM-DD')
    );
END;
/
```

---

## 7. 참고사항

### 7.1 WK_GUBUN 코드

| 코드 | 설명 |
|------|------|
| E | 이유 |
| F | 사고 (재발, 공태, 유산 등) |
| G | 교배 |
| B | 분만 |

### 7.2 STATUS_CD 코드 (TB_MODON)

| 코드 | 설명 |
|------|------|
| 010001 | 후보돈 |
| 010005 | 이유돈 |
| 010006 | 재발돈 |
| 010007 | 공태돈 |

### 7.3 농장 설정 코드 (TC_FARM_CONFIG)

| 코드 | 설명 | 기본값 |
|------|------|--------|
| 140007 | 초교배일 | 240 |
| 140008 | 평균재귀일 | 7 |
| 140002 | 임신기간 | 115 |
| 140003 | 이유기간 | 21 |
